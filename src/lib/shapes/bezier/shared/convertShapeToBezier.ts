import { type Editor, type TLBaseShape, type TLShape, type TLShapePartial } from '@tldraw/editor'
import type { JsonObject, JsonValue } from '@tldraw/utils'
import { GeometryConverter } from '../../../../store/modifiers/utils/GeometryConverter'
import type { BezierPoint, BezierShape } from './bezierShape'
import { BezierStateActions } from './bezierState'

interface ConversionOptions {
  /**
   * When true, skip entering edit mode after conversion.
   */
  skipEditMode?: boolean
}

/**
 * Replace a supported shape with a bezier shape using the outline generated by GeometryConverter.
 * Returns the newly created bezier shape when successful.
 */
export function convertShapeToBezier(
  editor: Editor,
  shape: TLBaseShape<string, Record<string, unknown>>,
  options: ConversionOptions = {}
): BezierShape | null {
  const polygon = GeometryConverter.shapeToPolygon(shape as unknown as TLShape)

  if (!polygon.length || !polygon[0]?.length || polygon[0][0]?.length === 0) {
    return null
  }

  const bezierData = GeometryConverter.polygonToBezierShape(
    polygon,
    shape as unknown as TLShape,
    editor
  )

  if (!bezierData.props.points.length) {
    return null
  }

  const { parentId, index, id, opacity, isLocked, meta } = shape

  const metaRecord = (meta ?? {}) as Record<string, JsonValue>
  const cleanedMeta: JsonObject = {
    ...metaRecord,
    convertedFromShapeType: shape.type,
  }

  delete cleanedMeta.isFlippedX
  delete cleanedMeta.isFlippedY

  let createdShape: BezierShape | null = null

  const { w, h, color, dash, size, fill, points, isClosed } = bezierData.props

  editor.run(() => {
    editor.deleteShapes([id])

    const partial: TLShapePartial<BezierShape> = {
      id,
      type: 'bezier',
      parentId,
      index,
      x: bezierData.x,
      y: bezierData.y,
      rotation: 0,
      opacity,
      isLocked,
      meta: cleanedMeta,
      props: {
        w,
        h,
        color,
        dash,
        size,
        fill,
        points,
        isClosed,
        editMode: false,
        selectedPointIndices: [],
        selectedSegmentIndex: undefined,
      },
    }

    editor.createShape(partial)

    const newShape = editor.getShape(id) as BezierShape | undefined
    if (!newShape) return

    if (!options.skipEditMode) {
      BezierStateActions.enterEditMode(editor, newShape)
    }

    createdShape = editor.getShape(id) as BezierShape | null
  })

  return createdShape
}

interface PolylinePoint {
  x: number
  y: number
}

interface PolylineConversionOptions extends ConversionOptions {
  isClosed?: boolean
  smoothingFactor?: number
}

/**
 * Replace a stroke-based shape with a bezier shape constructed from a polyline.
 */
export function convertPolylineToBezier(
  editor: Editor,
  shape: TLBaseShape<string, Record<string, unknown>>,
  polyline: PolylinePoint[],
  options: PolylineConversionOptions = {}
): BezierShape | null {
  if (!polyline.length) {
    return null
  }

  // Remove duplicate consecutive points to prevent zero-length segments
  const dedupedPolyline = polyline.filter((point, index, array) => {
    if (index === 0) return true
    const prev = array[index - 1]
    return !(Math.abs(point.x - prev.x) < 1e-3 && Math.abs(point.y - prev.y) < 1e-3)
  })

  if (dedupedPolyline.length < 2) {
    return null
  }

  const minX = Math.min(...dedupedPolyline.map((point) => point.x))
  const minY = Math.min(...dedupedPolyline.map((point) => point.y))
  const maxX = Math.max(...dedupedPolyline.map((point) => point.x))
  const maxY = Math.max(...dedupedPolyline.map((point) => point.y))

  const width = Math.max(maxX - minX, 1)
  const height = Math.max(maxY - minY, 1)

  const normalizedPoints = dedupedPolyline.map(({ x, y }) => ({
    x: x - minX,
    y: y - minY,
  }))

  const bezierPoints = createSmoothedBezierPointsFromPolyline(
    normalizedPoints,
    options.isClosed ?? false,
    options.smoothingFactor
  )

  const { parentId, index, id, opacity, isLocked, meta } = shape

  const metaRecord = (meta ?? {}) as Record<string, JsonValue>
  const cleanedMeta: JsonObject = {
    ...metaRecord,
    convertedFromShapeType: shape.type,
  }

  delete cleanedMeta.isFlippedX
  delete cleanedMeta.isFlippedY

  const shapeProps = shape.props as Record<string, unknown>
  const color = (typeof shapeProps.color === 'string' ? shapeProps.color : 'black') as 'black' | 'grey' | 'red' | 'orange' | 'yellow' | 'green' | 'blue' | 'light-blue' | 'violet' | 'light-violet' | 'light-red' | 'light-green'
  const size = (typeof shapeProps.size === 'string' ? shapeProps.size : 'm') as 's' | 'm' | 'l' | 'xl'
  const dash = (typeof shapeProps.dash === 'string' ? shapeProps.dash : 'solid') as 'draw' | 'solid' | 'dashed' | 'dotted'

  let createdShape: BezierShape | null = null

  editor.run(() => {
    editor.deleteShapes([id])

    const partial: TLShapePartial<BezierShape> = {
      id,
      type: 'bezier',
      parentId,
      index,
      x: minX,
      y: minY,
      rotation: 0,
      opacity,
      isLocked,
      meta: cleanedMeta,
      props: {
        w: width,
        h: height,
        color,
        dash,
        size,
        fill: 'none',
        points: bezierPoints,
        isClosed: options.isClosed ?? false,
        editMode: false,
        selectedPointIndices: [],
        selectedSegmentIndex: undefined,
      },
    }

    editor.createShape(partial)

    const newShape = editor.getShape(id) as BezierShape | undefined
    if (!newShape) return

    if (!options.skipEditMode) {
      BezierStateActions.enterEditMode(editor, newShape)
    }

    createdShape = editor.getShape(id) as BezierShape | null
  })

  return createdShape
}

function createSmoothedBezierPointsFromPolyline(
  points: { x: number; y: number }[],
  isClosed: boolean,
  smoothingFactorOverride?: number
): BezierPoint[] {
  const smoothingFactor = typeof smoothingFactorOverride === 'number' ? smoothingFactorOverride : 0.25

  const result: BezierPoint[] = points.map((point) => ({ x: point.x, y: point.y }))

  if (points.length < 2) {
    return result
  }

  const pointCount = points.length

  const getPoint = (index: number) => {
    if (isClosed) {
      const wrapped = (index + pointCount) % pointCount
      return points[wrapped]
    }
    const clamped = Math.max(0, Math.min(pointCount - 1, index))
    return points[clamped]
  }

  const distance = (a: { x: number; y: number }, b: { x: number; y: number }) => Math.hypot(b.x - a.x, b.y - a.y)

  const normalize = (x: number, y: number) => {
    const length = Math.hypot(x, y) || 1
    return { x: x / length, y: y / length }
  }

  for (let i = 0; i < pointCount; i++) {
    const point = points[i]
    const prevPoint = getPoint(i - 1)
    const nextPoint = getPoint(i + 1)

    const isEndpoint = !isClosed && (i === 0 || i === pointCount - 1)

    if (isEndpoint) {
      if (i === 0) {
        const tangent = normalize(nextPoint.x - point.x, nextPoint.y - point.y)
        const smoothing = distance(point, nextPoint) * smoothingFactor
        result[i].cp2 = {
          x: point.x + tangent.x * smoothing,
          y: point.y + tangent.y * smoothing,
        }
      } else {
        const tangent = normalize(point.x - prevPoint.x, point.y - prevPoint.y)
        const smoothing = distance(point, prevPoint) * smoothingFactor
        result[i].cp1 = {
          x: point.x - tangent.x * smoothing,
          y: point.y - tangent.y * smoothing,
        }
      }
      continue
    }

    const prevToNext = {
      x: nextPoint.x - prevPoint.x,
      y: nextPoint.y - prevPoint.y,
    }

    const tangent = normalize(prevToNext.x, prevToNext.y)
    const prevDistance = distance(point, prevPoint)
    const nextDistance = distance(point, nextPoint)
    const smoothing = Math.min(prevDistance, nextDistance) * smoothingFactor

    if (smoothing <= 1e-3) {
      continue
    }

    result[i].cp1 = {
      x: point.x - tangent.x * smoothing,
      y: point.y - tangent.y * smoothing,
    }

    result[i].cp2 = {
      x: point.x + tangent.x * smoothing,
      y: point.y + tangent.y * smoothing,
    }
  }

  return result
}
